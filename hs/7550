{
	"greeting": "Greetings from The On-Line Encyclopedia of Integer Sequences! http://oeis.org/",
	"query": "program:Haskell",
	"count": 8147,
	"start": 7550,
	"results": [
		{
			"number": 224345,
			"data": "1,3,11,53,323,2359,19877,188591,1981963,22795849,284285351,3815293199,54762206985,836280215979,13527449608779,230894574439485,4144741143359355,78017419806432567,1535903379571939981,31550210953904250759",
			"name": "Number of closed normal forms of size n in lambda calculus with size 0 for the variables.",
			"link": [
				"Pierre Lescanne, \u003ca href=\"/A224345/b224345.txt\"\u003eTable of n, a(n) for n = 1..500\u003c/a\u003e",
				"Maciej Bendkowski, K Grygiel, P Tarau, \u003ca href=\"http://arxiv.org/abs/1612.07682\"\u003eRandom generation of closed simply-typed lambda-terms: a synergy between logic programming and Boltzmann samplers\u003c/a\u003e, arXiv preprint arXiv:1612.07682, 2016",
				"K. Grygiel and P. Lescanne, \u003ca href=\"http://arxiv.org/abs/1210.2610\"\u003e Counting and generating lambda-terms\u003c/a\u003e, arXiv preprint arXiv:1210.2610 [cs.LO], 2012-2013.",
				"Paul Tarau, \u003ca href=\"http://www.cse.unt.edu/~tarau/research/2015/dbx.pdf\"\u003eOn logic programming representations of lambda terms: de Bruijn indices, compression, type inference, combinatorial generation, normalization\u003c/a\u003e, 2015.",
				"P. Tarau, \u003ca href=\"http://arxiv.org/abs/1507.06944\"\u003eA Logic Programming Playground for Lambda Terms, Combinators, Types and Tree-based Arithmetic Computations\u003c/a\u003e, arXiv preprint arXiv:1507.06944 [cs.LO], 2015.",
				"Paul Tarau, \u003ca href=\"https://arxiv.org/abs/1608.03912\"\u003eA Hiking Trip Through the Orders of Magnitude: Deriving Efficient Generators for Closed Simply-Typed Lambda Terms and Normal Forms\u003c/a\u003e, arXiv preprint arXiv:1608.03912 [cs.PL], 2016."
			],
			"formula": [
				"a(n) = F(n,0) where F(0,m) = m, F(n+1,m) = F(n,m+1) + G(n+1,m), and G(0,m) = m, G(n+1,m) = sum(k=0..n, G(n-k,m)*F(k,m)*d(n,0) ) where d(0,i) = [i = 1], d(n+1,i) = sum(j=i..n+1, binomial(j,i)*d(n,j) + g(n+1,j) ) and g(0,i) = [i = 1], g(n+1,i) = sum(j=0..i, sum(k=0..n, g(k,j)*d(n-k,i-j) ) )."
			],
			"mathematica": [
				"F[0, m_] := m; F[n_, m_] := F[n, m] = F[n-1, m+1] + G[n, m]; G[0, m_] := m; G[n_, m_] := G[n, m] = Sum[G[n-k-1, m]*F[k, m], {k, 0, n-1}]; a[n_] := F[n, 0]; Array[a, 20] (* _Jean-François Alcover_, May 23 2017 *)"
			],
			"program": [
				"(Haskell)",
				"gtab :: [[Integer]]",
				"gtab = [0..] : [[s n m |  m \u003c- [0..]] | n \u003c- [1..]]",
				"  where s n m  = let fi =  [ftab !! i !! m | i \u003c- [0..(n-1)]]",
				"                     gi =  [gtab !! i !! m | i \u003c- [0..(n-1)]]",
				"                 in foldl (+) 0 (map (uncurry (*)) (zip fi (reverse gi)))",
				"ftab :: [[Integer]]",
				"ftab = [0..] : [[ftab !! (n-1) !! (m+1) + gtab !! n !! m | m\u003c-[0..]] | n\u003c-[1..]]",
				"f(n,m) = ftab !! n !! m"
			],
			"xref": [
				"Cf. A220894, A135501, A220895, A220896, A220897.",
				"Cf. A195691 for another size of the terms."
			],
			"keyword": "nonn",
			"offset": "1,2",
			"author": "_Pierre Lescanne_, Apr 04 2013",
			"references": 2,
			"revision": 39,
			"time": "2018-01-20T11:51:36-05:00",
			"created": "2013-04-05T11:59:32-04:00"
		},
		{
			"number": 224363,
			"data": "2,5,11,17,19,29,37,41,43,53,59,67,71,73,83,89,101,103,107,109,127,131,137,149,151,157,163,173,179,181,191,197,199,211,227,229,233,239,241,257,263,269,271,277,281,293,307,311,313,331,337,347,349,353,367,373",
			"name": "Primes p such that there are no squares between p and the prime following p.",
			"comment": [
				"Legendre's Conjecture states that there is a prime between n^2 and (n+1)^2 for every integer n \u003e 0 and thus that between two adjacent primes there can be at most one square. As of April 2013, the conjecture is still unproved.",
				"a(n) = A000040(A221056(n)). - _Reinhard Zumkeller_, Apr 15 2013"
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A224363/b224363.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e",
				"Eric Weisstein's World of Mathematics, \u003ca href=\"http://mathworld.wolfram.com/LegendresConjecture.html\"\u003eLegendre's Conjecture\u003c/a\u003e",
				"Wikipedia, \u003ca href=\"http://en.wikipedia.org/wiki/Legendre%27s_conjecture\"\u003eLegendre's conjecture\u003c/a\u003e"
			],
			"example": [
				"5 is a term because there are no squares between the adjacent primes 5 and 7."
			],
			"mathematica": [
				"Select[Prime[Range[60]], Floor[Sqrt[NextPrime[#]]] == Floor[Sqrt[#]] \u0026] (* _Giovanni Resta_, Apr 10 2013 *)"
			],
			"program": [
				"(Haskell)",
				"a224363 = a000040 . a221056  -- _Reinhard Zumkeller_, Apr 15 2013"
			],
			"xref": [
				"Cf. A061265, A014085."
			],
			"keyword": "nonn",
			"offset": "1,1",
			"author": "_César Aguilera_, Apr 04 2013",
			"ext": [
				"Corrected and edited by _Giovanni Resta_, Apr 10 2013"
			],
			"references": 2,
			"revision": 13,
			"time": "2013-04-15T10:07:35-04:00",
			"created": "2013-04-12T13:20:13-04:00"
		},
		{
			"number": 224458,
			"data": "0,0,1,1,2,2,3,3,3,3,3,4,4,4,4,6,4,5,6,5,5,4,5,7,5,5,6,6,5,6,4,10,5,5,6,8,7,7,6,8,5,7,6,6,7,6,6,11,7,7,6,7,10,9,6,9,8,6,5,9,8,5,8,15,7,7,7,7,7,8,8,12,7,8,8,9,7,8,6,12,10,6,6,10,7,7,7,9",
			"name": "The Gordon-Scantlebury index of the rooted tree with Matula-Goebel number n.",
			"comment": [
				"The Gordon-Scantlebury index of a tree is the number of paths of length 2 between distinct vertices of the tree. See the Trinajstic reference (p. 115). It is 1/2 of the Platt index of the tree (A198332).",
				"The Matula-Goebel number of a rooted tree can be defined in the following recursive manner: to the one-vertex tree there corresponds the number 1; to a tree T with root degree 1 there corresponds the t-th prime number, where t is the Matula-Goebel number of the tree obtained from T by deleting the edge emanating from the root; to a tree T with root degree m\u003e=2 there corresponds the product of the Matula-Goebel numbers of the m branches of T."
			],
			"reference": [
				"F. Goebel, On a 1-1-correspondence between rooted trees and natural numbers, J. Combin. Theory, B 29 (1980), 141-143.",
				"I. Gutman and A. Ivic, On Matula numbers, Discrete Math., 150, 1996, 131-142.",
				"I. Gutman and Yeong-Nan Yeh, Deducing properties of trees from their Matula numbers, Publ. Inst. Math., 53 (67), 1993, 17-22.",
				"D. W. Matula, A natural rooted tree enumeration by prime factorization, SIAM Review, 10, 1968, 273.",
				"N. Trinajstic, Chemical Graph Theory, Vol. II, CRC Press, Boca Raton, 1983.",
				"E. Deutsch, Rooted tree statistics from Matula numbers, Discrete Appl. Math., 160, 2012, 2314-2322."
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A224458/b224458.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e",
				"\u003ca href=\"/index/Mat#matula\"\u003eIndex entries for sequences related to Matula-Goebel numbers\u003c/a\u003e"
			],
			"formula": [
				"a(1)=0; if n=p(t) (the t-th prime, t\u003e=2), then a(n)=a(t)+G(t); if n=rs (r,s\u003e=2), then a(n)=a(r)+a(s)+G(r)G(s); G(m) denotes the number of prime divisors of m counted with multiplicities."
			],
			"example": [
				"a(7)=3 because the rooted tree with Matula-Goebel number 7 is Y; obviously, it has 3 paths of length 2."
			],
			"maple": [
				"with(numtheory): a := proc (n) local r, s: r := proc (n) options operator, arrow: op(1, factorset(n)) end proc: s := proc (n) options operator, arrow: n/r(n) end proc: if n = 1 then 0 elif bigomega(n) = 1 then a(pi(n))+bigomega(pi(n)) else a(r(n))+a(s(n))+bigomega(r(n))*bigomega(s(n)) end if end proc: seq(a(n), n = 1 .. 100);"
			],
			"program": [
				"(Haskell)",
				"import Data.List (genericIndex)",
				"a224458 n = genericIndex a224458_list (n - 1)",
				"a224458_list = 0 : g 2 where",
				"   g x = y : g (x + 1) where",
				"     y | t \u003e 0     = a224458 t + a001222 t",
				"       | otherwise = a224458 r + a224458 s + a001222 r * a001222 s",
				"       where t = a049084 x; r = a020639 x; s = x `div` r",
				"-- _Reinhard Zumkeller_, Sep 03 2013"
			],
			"xref": [
				"Cf. A198332.",
				"Cf. A049084, A020639, A001222."
			],
			"keyword": "nonn",
			"offset": "1,5",
			"author": "_Emeric Deutsch_, Apr 14 2013",
			"references": 2,
			"revision": 11,
			"time": "2017-03-07T11:22:46-05:00",
			"created": "2013-04-14T14:32:02-04:00"
		},
		{
			"number": 224694,
			"data": "0,2,4,8,10,12,16,18,24,26,32,34,36,40,44,48,50,56,64,66,68,76,80,90,96,98,100,108,112,128,130,132,136,138,144,146,152,160,164,168,176,184,192,194,196,208,224,228,240,256,258,260,264,266,268,280,282,288,290,296,312",
			"name": "Numbers n such that n^2 AND n = 0, where AND is the bitwise logical AND operator.",
			"comment": [
				"Indices of zeros in A213541.",
				"The sequence b(n) = a(n)/2  begins: 0, 1, 2, 4, 5, 6, 8, 9, 12, 13, 16, 17, 18, 20, 22, 24, 25, 28, 32, 33, 34, 38, 40, 45, 48, 49, 50, 54, 56, 64"
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A224694/b224694.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e"
			],
			"maple": [
				"read(\"transforms\") :",
				"isA224694 := proc(n)",
				"    return( ANDnos(n^2,n) =0 ) ;",
				"end proc:",
				"A224694 := proc(n)",
				"    option remember;",
				"    if n = 1 then",
				"        0;",
				"    else",
				"        for a from procname(n-1)+1 do",
				"            if isA224694(a) then",
				"                return a;",
				"            end if;",
				"        end do:",
				"    end if;",
				"end proc: # _R. J. Mathar_, Apr 25 2013"
			],
			"mathematica": [
				"Select[Range[0, 350], BitAnd[#^2, #] == 0 \u0026] (* _Matthew House_, Jul 14 2015 *)"
			],
			"program": [
				"(Python)",
				"for i in range(333):",
				"    if ((i*i) \u0026 i)==0:",
				"      print str(i)+',',",
				"(Haskell)",
				"import Data.List (elemIndices)",
				"a224694 n = a224694_list !! (n-1)",
				"a224694_list = elemIndices 0 a213541_list",
				"-- _Reinhard Zumkeller_, Apr 25 2013"
			],
			"xref": [
				"Cf. A213541."
			],
			"keyword": "nonn,easy",
			"offset": "1,2",
			"author": "_Alex Ratushnyak_, Apr 15 2013",
			"references": 2,
			"revision": 20,
			"time": "2015-07-14T08:56:21-04:00",
			"created": "2013-04-25T17:55:31-04:00"
		},
		{
			"number": 224729,
			"data": "1,2,14,138,1522,17740,213642,2628626,32833226,414697740,5282720764,67750624480,873653602902,11316723314858,147143725788662,1919360958676866,25105597581410410,329174706398378884,4325098764217263996,56934186664360843064",
			"name": "Central terms of the triangle in A059283.",
			"comment": [
				"a(n) = A059283(2*n,n)."
			],
			"program": [
				"(Haskell)",
				"a224729 n = a059283 (2*n) n"
			],
			"keyword": "nonn",
			"offset": "0,2",
			"author": "_Reinhard Zumkeller_, Apr 17 2013",
			"references": 2,
			"revision": 9,
			"time": "2013-04-18T02:04:04-04:00",
			"created": "2013-04-18T02:04:04-04:00"
		},
		{
			"number": 224791,
			"data": "0,1,2,2,5,8,3,10,23,32,4,17,50,105,138,5,26,93,248,491,630,6,37,156,497,1236,2357,2988,7,50,243,896,2629,6222,11567,14556,8,65,358,1497,5022,13873,31662,57785,72342,9,82,505,2360,8879,27774,73309,162756",
			"name": "Triangle T(n,k) read by rows: left edge is 0, 1, 2, ... (cf. A001477); otherwise each entry is sum of entry to left and entries immediately above it to left and right, with 1 for the missing right term at right edge.",
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A224791/b224791.txt\"\u003eRows n = 0..120 of triangle, flattened\u003c/a\u003e",
				"\u003ca href=\"/index/Pas#Pascal\"\u003eIndex entries for triangles and arrays related to Pascal's triangle\u003c/a\u003e"
			],
			"formula": [
				"T(n,0) = n, T(n+1,k) = T(n+1,k-1) + T(n,k-1) + T(n,k) (0 \u003c k \u003c= n) and T(n+1,n+1) = T(n+1,n) + T(n,n) + 1."
			],
			"example": [
				"Triangle begins:",
				"  0;",
				"  1,  2;",
				"  2,  5,  8;",
				"  3, 10, 23,  32;",
				"  4, 17, 50, 105, 138;"
			],
			"maple": [
				"T:= proc(n, k) option remember;",
				"      if k=0 then n",
				"    elif k=n then T(n,n-1) + T(n-1,n-1) + 1",
				"    else T(n,k-1) + T(n-1,k-1) + T(n-1, k)",
				"      fi",
				"    end:",
				"seq(seq(T(n, k), k=0..n), n=0..12); # _G. C. Greubel_, Nov 12 2019"
			],
			"mathematica": [
				"T[n_, k_]:= T[n, k]= If[k==0, n, If[k==n , T[n, n-1] + T[n-1, n-1] + 1, T[n, k-1] + T[n-1, k-1] + T[n-1, k]]]; Table[T[n, k], {n, 0, 12}, {k, 0, n}]//Flatten (* _G. C. Greubel_, Nov 12 2019 *)"
			],
			"program": [
				"(Haskell)",
				"a224791 n k = a224791_tabl !! n !! k",
				"a224791_row n = a224791_tabl !! n",
				"a224791_tabl = iterate",
				"   (\\row -\u003e scanl1 (+) $ zipWith (+) ([1] ++ row) (row ++ [1])) [0]",
				"(PARI) T(n,k) = if(k==0, n, if(k==n, T(n,n-1) + T(n-1,n-1) + 1, T(n,k-1) + T(n-1,k-1) + T(n-1, k) )); \\\\ _G. C. Greubel_, Nov 12 2019",
				"(Sage)",
				"@CachedFunction",
				"def T(n, k):",
				"    if (k==0): return n",
				"    elif (k==n): return T(n,n-1) + T(n-1,n-1) + 1",
				"    else: return T(n,k-1) + T(n-1,k-1) + T(n-1, k)",
				"[[T(n, k) for k in (0..n)] for n in (0..12)] # _G. C. Greubel_, Nov 12 2019"
			],
			"xref": [
				"Cf. A051601, A059283."
			],
			"keyword": "nonn,tabl,changed",
			"offset": "0,3",
			"author": "_Reinhard Zumkeller_, Apr 18 2013",
			"references": 2,
			"revision": 11,
			"time": "2019-11-13T01:48:26-05:00",
			"created": "2013-04-18T16:59:28-04:00"
		},
		{
			"number": 224839,
			"data": "1,3,6,8,11,13,16,18,21,23,35,40,45,53,58,63,66,68,73,86,96,110,120,125,128,131,133,138,143,148,151,171,178,181,183,188,193,198,205,211,216,239,244,250,256,258,261,263,268,273",
			"name": "a(1) = 1 and a(n) is the smallest number greater than a(n-1) with no square difference with any preceding term.",
			"comment": [
				"The first 11 terms are identical to those of A210570."
			],
			"link": [
				"Jean-François Alcover, \u003ca href=\"/A224839/b224839.txt\"\u003eTable of n, a(n) for n = 1..1000\u003c/a\u003e"
			],
			"maple": [
				"N:= 1000: # to get all terms \u003c= N",
				"V:= Vector(N):",
				"Res:= NULL:",
				"for m from 1 to N do",
				"  if V[m] = 0 then",
				"    V[m]:= 1;",
				"    Res:= Res, m;",
				"    for k from 1 to floor(sqrt(N-m)) do V[m+k^2]:= 1 od:",
				"  fi",
				"od:",
				"Res; # _Robert Israel_, Nov 30 2016"
			],
			"mathematica": [
				"a[1] = 1; a[n_] := a[n] = For[k = a[n-1]+1, True, k++, If[FreeQ[k - Array[a, n-1], d_ /; IntegerQ[Sqrt[d]]], Return[k]]]; Table[a[n], {n, 1, 40}]"
			],
			"program": [
				"(Haskell)",
				"a224839 n = a224839_list !! (n-1)",
				"a224839_list = f [1..] [] where",
				"   f (x:xs) ys = if all ((== 0) . a010052) $ map (x -) ys",
				"                    then x : f xs (x:ys) else f xs ys",
				"-- _Reinhard Zumkeller_, May 02 2014"
			],
			"xref": [
				"Cf. A210570.",
				"Cf. A010052."
			],
			"keyword": "nonn",
			"offset": "1,2",
			"author": "_Jean-François Alcover_, Sep 18 2013",
			"references": 2,
			"revision": 24,
			"time": "2016-12-01T01:32:27-05:00",
			"created": "2013-09-28T03:45:23-04:00"
		},
		{
			"number": 224841,
			"data": "1,2,12,3,23,123,4,34,234,1234,5,45,345,2345,12345,6,56,456,3456,23456,123456,7,67,567,4567,34567,234567,1234567,8,78,678,5678,45678,345678,2345678,12345678,9,89,789,6789,56789,456789,3456789,23456789,123456789",
			"name": "Triangle T(n,k) read by rows: Substring of k digits of sequence A007376, ending at position n, 1 \u003c= k \u003c= n.",
			"comment": [
				"In contrast to sequence A162711, this sequence contains each substring without leading zero of A007376 at least once."
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A224841/b224841.txt\"\u003eRows n = 1..125 of table, flattened\u003c/a\u003e"
			],
			"program": [
				"(PARI) for(i=1,9,for(j=1,i,for(k=i-j+1,i,print1(k));print1(\",\")))",
				"(Haskell)",
				"import Data.List (inits, tails)",
				"a224841 n k = a224841_tabl !! (n-1) !! (k-1)",
				"a224841_row n = a224841_tabl !! (n-1)",
				"a224841_tabl = map",
				"   (reverse . map (read . concatMap show) . init . tails) $",
				"   tail $ inits a007376_list :: [[Integer]]",
				"-- _Reinhard Zumkeller_, Nov 11 2013"
			],
			"keyword": "nonn,easy,base,tabl",
			"offset": "1,2",
			"author": "_M. F. Hasler_, Jul 22 2013",
			"references": 2,
			"revision": 13,
			"time": "2013-11-11T10:30:37-05:00",
			"created": "2013-07-22T05:09:31-04:00"
		},
		{
			"number": 224909,
			"data": "1,1,0,1,1,2,3,0,3,3,6,3,9,2,11,3,0,3,3,6,9,2,11,0,11,11,6,17,11,9,20,5,25,3,28,7,5,12,17,6,23,10,0,10,10,20,3,23,0,23,23,17,4,21,25,15,40,1,41,4,45,15,12,27,1,28,29,18,47,19,14,33,7,40",
			"name": "a(1) = a(2) = 1; a(n) = (a(n-1) + a(n-2)) mod (n - a(n-1)).",
			"comment": [
				"Performing the modulus operation, the smallest nonnegative residue is to be taken.",
				"a(A226483(n)) = n and a(m) \u003c\u003e n for m \u003c A226483(n). - _Reinhard Zumkeller_, Jun 09 2013"
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A224909/b224909.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e"
			],
			"example": [
				"a(8) = (a(7) + a(6)) mod (8 - a(7)) = (2+3) mod (8-3) = 5 mod 5 = 0."
			],
			"mathematica": [
				"a[1]=1; a[2]=1; a[n_] := a[n] = Mod[a[n-1] + a[n-2], n - a[n-1]]; Array[a, 74] (* _Giovanni Resta_, Jun 08 2013 *)"
			],
			"program": [
				"(Haskell)",
				"a224909 n = a224909_list !! (n-1)",
				"a224909_list = 1 : 1 : zipWith mod",
				"   (zipWith (+) a224909_list $ tail a224909_list)",
				"   (zipWith (-) [3..] $ tail a224909_list)",
				"-- _Reinhard Zumkeller_, Jun 09 2013"
			],
			"keyword": "nonn",
			"offset": "1,6",
			"author": "_David S. Newman_, Apr 19 2013",
			"ext": [
				"a(31)-a(74) from _Giovanni Resta_, Jun 08 2013"
			],
			"references": 2,
			"revision": 18,
			"time": "2015-08-11T05:15:30-04:00",
			"created": "2013-06-08T18:06:31-04:00"
		},
		{
			"number": 225047,
			"data": "1,2,3,5,4,6,7,9,10,12,8,13,11,16,17,19,14,20,15,23,21,24,18,28,22,27,25,31,26,36,29,32,33,35,30,40,34,39,37,43,38,44,41,47,48,50,42,54,45,51,49,55,46,58,52,59,53,62,56,63,57,66,64,67,60,71,61",
			"name": "Inverse permutation of A121216.",
			"comment": [
				"A121216(a(n)) = a(A121216(n)) = n."
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A225047/b225047.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e",
				"\u003ca href=\"/index/Per#IntegerPermutation\"\u003eIndex entries for sequences that are permutations of the natural numbers\u003c/a\u003e"
			],
			"program": [
				"(Haskell)",
				"import Data.List (elemIndex)",
				"import Data.Maybe (fromJust)",
				"a225047 = (+ 1) . fromJust . (`elemIndex` a121216_list)"
			],
			"keyword": "nonn",
			"offset": "1,2",
			"author": "_Reinhard Zumkeller_, Apr 25 2013",
			"references": 2,
			"revision": 4,
			"time": "2013-04-25T16:45:59-04:00",
			"created": "2013-04-25T16:45:59-04:00"
		}
	]
}