{
	"greeting": "Greetings from The On-Line Encyclopedia of Integer Sequences! http://oeis.org/",
	"query": "program:Haskell",
	"count": 8147,
	"start": 7710,
	"results": [
		{
			"number": 252477,
			"data": "3,1,2,1,3,1,4,2,1,5,1,3,6,3,2,2,7,2,4,8,2,4,3,2,4,10,5,10,5,1,5,3,11,2,12,4,4,6,4,4,13,2,13,6,14,2,2,7,15,7,5,15,3,5,5,5,16,5,8,16,3,2,8,17,8,2,6,3,18,9,6,4,6,6,9,6,4,9,5,4,20,4,20,6,10,7,5,10,21,10,3,5",
			"name": "Integer part of 1/(sqrt(prime(n+1))-sqrt(prime(n))).",
			"comment": [
				"Andrica's conjecture states that sqrt(prime(n+1))-sqrt(prime(n)) \u003c 1 for all n. Since equality cannot happen, this is equivalent to say that all terms of is sequence are \u003e= 1.",
				"Sequence A074976 is based on the same idea (rounding to the nearest integer instead).",
				"It is a remarkable coincidence(?) that very often, especially around \"peaks\", a symmetric pattern \"x, y, x\" occurs: 2, 7, 2,... 10, 5, 10,... 13, 2, 13,... 20, 4, 20, ..., 11, 5, 11, ...",
				"Equal to the integer part of (A000006(n+1)+A000006(n))/(prime(n+1)-prime(n)) for most indices; exceptions are 1, 129, 1667, 2004, 2088, 2334, 3377, 3585, 3695, 3834, 4978, 7057, 7950, 8103, 9525, 9805,..."
			],
			"link": [
				"M. F. Hasler, \u003ca href=\"/A252477/b252477.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e",
				"Eric Weisstein's World of Mathematics, \u003ca href=\"http://mathworld.wolfram.com/AndricasConjecture.html\"\u003eAndrica's conjecture\u003c/a\u003e"
			],
			"example": [
				"a(1) = floor(1/(sqrt(3) - sqrt(2))) = floor(1/(1.73-1.41)) = floor(1/0.32) = floor(3.15) = 3.",
				"a(2) = floor(1/(sqrt(5) - sqrt(3))) = floor(1/(2.236-1.732)) = floor(1/0.504) = floor(1.98) = 1."
			],
			"program": [
				"(PARI) a(n)=1\\(sqrt(prime(n+1))-sqrt(prime(n))) \\\\ _M. F. Hasler_, Dec 31 2014",
				"(Haskell)",
				"a252477 n = a252477_list !! (n-1)",
				"a252477_list = map (floor . recip) $ zipWith (-) (tail rs) rs",
				"               where rs = map (sqrt . fromIntegral) a000040_list",
				"-- _Reinhard Zumkeller_, Jan 04 2015"
			],
			"xref": [
				"Cf. A000040, A074976."
			],
			"keyword": "nonn",
			"offset": "1,1",
			"author": "_M. F. Hasler_, Dec 31 2014",
			"references": 2,
			"revision": 10,
			"time": "2015-01-04T00:18:25-05:00",
			"created": "2015-01-02T11:22:15-05:00"
		},
		{
			"number": 252837,
			"data": "0,9,6,3,0,0,6,9,5,0,8,4,0,6,6,6,2,10,5,2,4,13,9,10,5,3,5,2,4,13,4,6,2,11,2,4,8,4,5,5,3,10,4,3,2,8,13,5,3,4,8,2,6,4,10,5,3,6,4,4",
			"name": "Let c = A098550. Let c(n) be prime. If c(n+1) is even, then a(n) is the maximal number r of consecutive even numbers of the form c(n+1), c(n+3), ..., c(n+(2r-1)); if c(n+1) is odd, then a(n)=0.",
			"comment": [
				"Conjecture:",
				"Let c(n)\u003e=43 be prime. Then",
				"1) c(n+1) is even;",
				"2) c(n+(2*a(n)-1)) = 2*q, where q\u003ec(n) is prime;",
				"3) If c(n)\u003e=97 is prime, then in 2) q is the next prime after c(n)."
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A252837/b252837.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e",
				"David L. Applegate, Hans Havermann, Bob Selcoe, Vladimir Shevelev, N. J. A. Sloane, and Reinhard Zumkeller, The Yellowstone Permutation, arXiv preprint arXiv:1501.01669, 2015 and \u003ca href=\"https://cs.uwaterloo.ca/journals/JIS/VOL18/Sloane/sloane9.html\"\u003eJ. Int. Seq. 18 (2015) 15.6.7\u003c/a\u003e."
			],
			"program": [
				"(Haskell)",
				"a252837 n = a252837_list !! (n-1)",
				"a252837_list = f a098550_list where",
				"   f us = (h 0 vs) : f vs where",
				"     (_:vs) = dropWhile ((== 0) . a010051') us",
				"     h e (w:_:ws) = if even w then h (e + 1) ws else e",
				"-- _Reinhard Zumkeller_, Mar 11 2015"
			],
			"xref": [
				"Cf. A098550, A252838.",
				"Cf. A010051."
			],
			"keyword": "nonn",
			"offset": "1,2",
			"author": "_Vladimir Shevelev_, Dec 22 2014",
			"references": 2,
			"revision": 30,
			"time": "2018-05-15T16:48:41-04:00",
			"created": "2014-12-25T23:38:04-05:00"
		},
		{
			"number": 252849,
			"data": "4,8,9,12,18,20,24,25,27,28,36,40,44,45,49,50,52,54,56,60,63,64,68,72,75,76,84,88,90,92,98,99,100,104,108,116,117,120,121,124,125,126,128,132,135,136,140,144,147,148",
			"name": "Numbers with an even number of square divisors.",
			"comment": [
				"Closed lockers in the locker problem where the student numbers are the set of perfect squares.",
				"The locker problem is a classic mathematical problem. Imagine a row containing an infinite number of lockers numbered from one to infinity. Also imagine an infinite number of students numbered from one to infinity. All of the lockers begin closed. The first student opens every locker that is a multiple of one, which is every locker. The second student closes every locker that is a multiple of two, so all of the even-numbered lockers are closed. The third student opens or closes every locker that is a multiple of three. This process continues for all of the students.",
				"A variant on the locker problem is when not all student numbers are considered; in the case of this sequence, only the square-numbered students open and close lockers. The sequence here is a list of the closed lockers after all of the students have gone."
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A252849/b252849.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e",
				"K. A. P. Dagal, \u003ca href=\"http://arxiv.org/abs/1307.6455\"\u003eGeneralized Locker Problem\u003c/a\u003e, arXiv:1307.6455 [math.NT], 2013.",
				"B. Torrence and S. Wagon, \u003ca href=\"https://cms.math.ca/crux/v33/n4/page232-236.pdf\"\u003eThe Locker Problem\u003c/a\u003e, Crux Mathematicorum, 2007, 33(4), 232-236."
			],
			"mathematica": [
				"Position[Length@ Select[Divisors@ #, IntegerQ@ Sqrt@ # \u0026] \u0026 /@",
				"Range@ 150, _Integer?EvenQ] // Flatten (* _Michael De Vlieger_, Mar 23 2015 *)"
			],
			"program": [
				"(C++)",
				"#include \u003ciostream\u003e",
				"using namespace std;",
				"int main()",
				"{",
				"  const int one_k = 1000;",
				"  //all numbers in sequence up to one_k are given",
				"  int lockers [one_k] = {};",
				"  int A = 0;",
				"  while (A \u003c one_k) {",
				"    lockers [A] = A+1;",
				"     A = A + 1;",
				"  }",
				"  int B = 1;",
				"  while ( ((B+1) * (B+1)) \u003c= one_k) {",
				"    int C = ((B+1) * (B+1));",
				"    int D = one_k/C;",
				"    int E = 1;",
				"    while (E \u003c= D) {",
				"      lockers [(C*E)-1] = -1 * lockers [(C*E)-1];",
				"      E = E + 1;",
				"    }",
				"    B = B + 1;",
				"  }",
				"  int F = 0;",
				"  while (F \u003c one_k) {",
				"    if (lockers [F] \u003c 0) {",
				"      cout \u003c\u003c (-1 * lockers [F]) \u003c\u003c endl;",
				"    }",
				"    F = F + 1;",
				"  }",
				"  return 0;",
				"}  /* _Walker Dewey Anderson_, Mar 22 2015 */",
				"(PARI) isok(n) = sumdiv(n, d, issquare(d)) % 2 == 0; \\\\ _Michel Marcus_, Mar 22 2015",
				"(Haskell)",
				"a252849 n = a252849_list !! (n-1)",
				"a252849_list = filter (even . a046951) [1..]",
				"-- _Reinhard Zumkeller_, Apr 06 2015"
			],
			"xref": [
				"Cf. A000290, A252895.",
				"Cf. A046951."
			],
			"keyword": "nonn",
			"offset": "1,1",
			"author": "_Walker Dewey Anderson_, Mar 22 2015",
			"references": 2,
			"revision": 40,
			"time": "2015-04-06T21:12:27-04:00",
			"created": "2015-04-06T16:54:29-04:00"
		},
		{
			"number": 252895,
			"data": "1,2,3,5,6,7,10,11,13,14,15,16,17,19,21,22,23,26,29,30,31,32,33,34,35,37,38,39,41,42,43,46,47,48,51,53,55,57,58,59,61,62,65,66,67,69,70,71,73,74,77,78,79,80,81,82,83,85,86,87,89,91,93,94,95,96,97",
			"name": "Numbers with an odd number of square divisors.",
			"comment": [
				"Open lockers in the locker problem where the student numbers are the set of perfect squares.",
				"The locker problem is a classic mathematical problem. Imagine a row containing an infinite number of lockers numbered from one to infinity. Also imagine an infinite number of students numbered from one to infinity. All of the lockers begin closed. The first student opens every locker that is a multiple of one, which is every locker. The second student closes every locker that is a multiple of two, so all of the even-numbered lockers are closed. The third student opens or closes every locker that is a multiple of three. This process continues for all of the students.",
				"A variant on the locker problem is when not all student numbers are considered; in the case of this sequence, only the square-numbered students open and close lockers. The sequence here is a list of the open lockers after all of the students have gone.",
				"n is in the sequence if and only if it is the product of a squarefree number (A005117) and a fourth power (A000583). - _Robert Israel_, Apr 07 2015",
				"Let D be the multiset containing d0(k), the divisor counting function, for each divisor k of n. n is in the sequence if and only if D admits a partition into two parts A and B such that the sum of the elements of A is exactly one more or less than the sum of the elements of B. For example, if n = 80, we have D = {1, 2, 2, 3, 4, 4, 5, 6, 8, 10}, and A = {1, 2, 3, 4, 4, 8} and B = {2, 5, 6, 10}. The sum of A is 22, and the sum of B is 23. - _Griffin N. Macris_, Oct 10 2016"
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A252895/b252895.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e",
				"K. A. P. Dagal, \u003ca href=\"http://arxiv.org/abs/1307.6455\"\u003eGeneralized Locker Problem\u003c/a\u003e, arXiv:1307.6455 [math.NT], 2013.",
				"B. Torrence and S. Wagon, \u003ca href=\"https://cms.math.ca/crux/v33/n4/page232-236.pdf\"\u003eThe Locker Problem\u003c/a\u003e, Crux Mathematicorum, 2007, 33(4), 232-236."
			],
			"example": [
				"The set of divisors of 6 is {1,2,3,6}, which contains only one perfect square: 1; therefore 6 is a term.",
				"The set of divisors of 16 is {1,2,4,8,16}, which contains three perfect squares: 1, 4, and 16; therefore 16 is a term.",
				"The set of divisors of 4 is {1,2,4}, which contains two perfect squares: 1 and 4; therefore 4 is not a term."
			],
			"maple": [
				"N:= 1000: # to get all terms \u003c= N",
				"S:= select(numtheory:-issqrfree, {$1..N}):",
				"map(s -\u003e seq(s*i^4, i = 1 .. floor((N/s)^(1/4))), S);",
				"# if using Maple 11 or earlier, uncomment the next line",
				"# sort(convert(%,list)); # _Robert Israel_, Apr 07 2015"
			],
			"mathematica": [
				"Position[Length@ Select[Divisors@ #, IntegerQ@ Sqrt@ # \u0026] \u0026 /@ Range@ 70, _Integer?OddQ] // Flatten (* _Michael De Vlieger_, Mar 23 2015 *)",
				"a[n_] := DivisorSigma[0, Total[EulerPhi/@Select[Sqrt[Divisors[n]], IntegerQ]]]; Flatten[Position[a/@Range@100,_?OddQ]] (* _Ivan N. Ianakiev_, Apr 07 2015 *)",
				"Select[Range@ 100, OddQ@ Length@ DeleteCases[Divisors@ #, k_ /; ! IntegerQ@ Sqrt@ k] \u0026] (* _Michael De Vlieger_, Oct 10 2016 *)"
			],
			"program": [
				"(C++)",
				"#include \u003ciostream\u003e",
				"using namespace std;",
				"int main()",
				"{",
				"const int one_k = 1000;",
				"//all numbers in sequence up to one_k are given",
				"int lockers [one_k] = {};",
				"int A = 0;",
				"while (A \u003c one_k) {",
				"  lockers [A] = A+1;",
				"  A = A + 1;",
				"}",
				"int B = 1;",
				"while ( ((B) * (B)) \u003c= one_k) {",
				"  int C = ((B) * (B));",
				"  int D = one_k/C;",
				"  int E = 1;",
				"  while (E \u003c= D) {",
				"    lockers [(C*E)-1] = -1 * lockers [(C*E)-1];",
				"    E = E + 1;",
				"  }",
				"  B = B + 1;",
				"}",
				"int F = 0;",
				"while (F \u003c one_k) {",
				"  if (lockers [F] \u003c 0) {",
				"    cout \u003c\u003c (-1 * lockers [F]) \u003c\u003c endl;",
				"  }",
				"F = F + 1;",
				"}",
				"return 0;",
				"} // _Walker Dewey Anderson_, Mar 22 2015",
				"(PARI) isok(n) = sumdiv(n, d, issquare(d)) % 2; \\\\ _Michel Marcus_, Mar 22 2015",
				"(Sage) [n for n in [1..200] if len([x for x in divisors(n) if is_square(x)])%2==1] # _Tom Edgar_, Mar 22 2015",
				"(Haskell)",
				"a252895 n = a252895_list !! (n-1)",
				"a252895_list = filter (odd . a046951) [1..]",
				"-- _Reinhard Zumkeller_, Apr 06 2015"
			],
			"xref": [
				"Cf. A000290, A000583, A005117, A046951, A252849."
			],
			"keyword": "nonn",
			"offset": "1,2",
			"author": "_Walker Dewey Anderson_, Mar 22 2015",
			"references": 2,
			"revision": 72,
			"time": "2016-11-06T02:22:23-05:00",
			"created": "2015-04-06T16:55:05-04:00"
		},
		{
			"number": 253138,
			"data": "0,0,1,1,0,1,1,1,1,2,1,3,2,4,3,4,3,3,5,7,6,5,5,8,8,7,9,7,10,10,12,11,15,12,14,14,13,11,13,15,15,14,15,20,14,15,19,20,16,17,17,17,21,24,23,24,28,23,25,24,27,25,32,29,25,21,26,31,31,29,36,32",
			"name": "Number of ways to represent the n-th prime as the arithmetic mean of two semiprimes.",
			"comment": [
				"Conjecture: a(n)\u003e0 for n\u003e5.",
				"Note that a(n) = A241535(n) = A241536(n) = 0 for n=1,2 and 5. - _Michel Marcus_, Mar 26 2015",
				"Among the a(n) decompositions of prime(n) into two semiprimes (prime(n)+ k)/2 and (prime(n)-k)/2, there is one where k is minimum with k = A241536(n) and there is one where k is maximum with k = prime(n) - A241535(n)."
			],
			"link": [
				"Michel Lagneau, \u003ca href=\"/A253138/b253138.txt\"\u003eTable of n, a(n) for n = 1..1000\u003c/a\u003e"
			],
			"example": [
				"a(12)=3 as prime(12) = 37 = (9+65)/2 = (25+49)/2 =(35+39)/2 where 9, 25, 35, 39, 49 and 65 are semiprime."
			],
			"maple": [
				"with(numtheory):for n from 1 to 100 do:c:=0:p:=ithprime(n):for m from 1 to p-1 do:p1:=p-m:p2:=p+m:if bigomega(p1)=2 and bigomega(p2)=2 then c:=c+1:else fi:od:printf(`%d, `,c):od:"
			],
			"mathematica": [
				"Reap[For[n=1, n \u003c= 100, n++, c=0; p = Prime[n]; For[m=1, m \u003c= p-1, m++, p1 = p-m; p2 = p+m; If[PrimeOmega[p1] == 2 \u0026\u0026 PrimeOmega[p2] == 2 , c = c+1]]; Print[c]; Sow[c]]][[2, 1]] (* _Jean-François Alcover_, Mar 23 2015, translated from Maple *)"
			],
			"program": [
				"(Haskell)",
				"a253138 n = sum $ map a064911 $",
				"   takeWhile (\u003e 0) $ map (2 * p -) $ dropWhile (\u003c p) a001358_list",
				"   where p = a000040 n",
				"-- _Reinhard Zumkeller_, Mar 27 2015"
			],
			"xref": [
				"Cf. A001358, A071681, A241535, A241536.",
				"Cf. A064911, A000040."
			],
			"keyword": "nonn",
			"offset": "1,10",
			"author": "_Michel Lagneau_, Mar 23 2015",
			"references": 2,
			"revision": 23,
			"time": "2015-03-27T18:08:55-04:00",
			"created": "2015-03-27T09:20:27-04:00"
		},
		{
			"number": 253253,
			"data": "1,23,2,3,4,67,6,89,5,337,8,1213,9,283,379,7,859,17,10,43,1061,13,14,25,421,37,11,41,293,433,12,53,1667,15,16,3637,21,349,20,449,19,4243,24,35,2273,1549,1187,373,18,5051,28,51,2677,1091,463,5657,2879,27",
			"name": "a(n) = smallest divisor of the concatenation of n and n+1 that did not occur earlier.",
			"comment": [
				"Is this a permutation of the integers \u003e 0 ?",
				"Comment from _N. J. A. Sloane_, May 19 2017 (Start):",
				"It should not be difficult to prove that every positive integer appears.",
				"If not, let m be the smallest missing number. There is an n_0 such that for all n \u003e= n_0, a(n) \u003e m. The theorem will follow if we can find an N \u003e n_0 such that",
				"m divides the concatenation of N and N+1.",
				"Let N have k digits and suppose that",
				"10^(k-1) \u003c= N \u003c= 10^k - 2.",
				"The concatenation of N and N+1 is N*(10^k+1)+1, so we want to find numbers k and N such that",
				"N*(10^k+1) == -1 mod m.",
				"Case (i). If gcd(m,10)=1, then by Euler's theorem, 10^phi(m) == 1 mod m, so we can take k to be a sufficiently large multiple of phi(m), and then take N to be a number of the form r*m-1 in the range 10^(k-1) \u003c= N \u003c= 10^k - 2.",
				"Case (ii). If m = 2^r or 5^r, then for large k, 10^k+1 == 1 mod m, and we take N to be of the form m*s-1 in the range 10^(k-1) \u003c= N \u003c= 10^k - 2.",
				"The other cases are left to the reader. (End)"
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A253253/b253253.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e",
				"Éric Angelini, \u003ca href=\"http://list.seqfan.eu/pipermail/seqfan/2015-June/014947.html\"\u003eDivisors of the concatenation of n and n+1\u003c/a\u003e, SeqFan list, Jun 03 2015."
			],
			"program": [
				"(Haskell)",
				"import Data.List (insert); import Data.List.Ordered (minus)",
				"a253253 n = a253253_list !! (n-1)",
				"a253253_list = f a001704_list [] where",
				"   f (x:xs) ds = y : f xs (insert y ds) where",
				"                 y = head (a027750_row' x `minus` ds)"
			],
			"xref": [
				"Cf. A027750, A001704, A256285."
			],
			"keyword": "nonn,base,look",
			"offset": "1,2",
			"author": "_Eric Angelini_ and _Reinhard Zumkeller_, Jun 05 2015",
			"references": 2,
			"revision": 15,
			"time": "2017-05-19T12:35:06-04:00",
			"created": "2015-06-05T11:05:55-04:00"
		},
		{
			"number": 253425,
			"data": "1,1,6,11,18,12,5,22,91,143,1,93,370",
			"name": "Lengths of runs of identical terms in A253415.",
			"program": [
				"(Haskell)",
				"import Data.List (group)",
				"a253425 n = a253425_list !! (n-1)",
				"a253425_list = map length $ group a253415_list"
			],
			"xref": [
				"Cf. A253415, A095258."
			],
			"keyword": "nonn",
			"offset": "1,3",
			"author": "_Reinhard Zumkeller_, Dec 31 2014",
			"references": 2,
			"revision": 3,
			"time": "2014-12-31T17:42:54-05:00",
			"created": "2014-12-31T17:42:54-05:00"
		},
		{
			"number": 253717,
			"data": "2,3,5,7,11,13,17,31,53,71,101,131,157,173,181,197,211,283,431,439,457,461,487,509,571,601,643,727,911,929,1021,1031,1033,1051,1093,1151,1163,1171,1201,1231,1249,1259,1301,1303,1327,1373,1399,1429,1451,1453,1493",
			"name": "Primes equal to their partial cyclical digital sum numbers.",
			"comment": [
				"Subsequence of primes of A106039. - _Michel Marcus_, May 03 2015"
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A253717/b253717.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e"
			],
			"example": [
				"Prime(37) = 157 = (1+5+7)*12 + 1.",
				"Prime(40) = 173 = (1+7+3)*15 + 1+7.",
				"Prime(42) = 181 = (1+8+1)*18 + 1."
			],
			"mathematica": [
				"terms = {}; (Do[p = Prime[n]; iD = IntegerDigits[p]; iD[[0]] = 0;",
				"  a = Apply[Plus, iD]; pf = p - Mod[p, Floor[p/a]*a];",
				"  (Do[pf = pf + Apply[Plus, iD[[i]]];",
				"    If[pf == p, AppendTo[terms, pf]], {i, 0, IntegerLength[Prime[n]]}]), {n,",
				"   1, 1000}]); Union[terms]"
			],
			"program": [
				"(PARI) isok(n) = {my(v = divrem(n, sumdigits(n))[2]); if (!v, return (1)); d = digits(n); for (i=1, #d, v -= d[i]; if (!v, return (1));); return (0);}",
				"lista(nn) = forprime (n=1, nn, if (isok(n), print1(n, \", \"))); \\\\ _Michel Marcus_, May 03 2015",
				"(Haskell)",
				"a253717 n = a253717_list !! (n-1)",
				"a253717_list = filter ((== 1) . a010051') a106039_list",
				"-- _Reinhard Zumkeller_, May 07 2015"
			],
			"xref": [
				"Cf. A257275.",
				"Cf. A106039."
			],
			"keyword": "nonn,base",
			"offset": "1,1",
			"author": "_V.J. Pohjola_, May 02 2015",
			"references": 2,
			"revision": 23,
			"time": "2015-05-07T12:14:17-04:00",
			"created": "2015-05-07T03:45:50-04:00"
		},
		{
			"number": 253910,
			"data": "21,34,56,78,119,1310,1712,1914,2315,2916,3118,3720,4121,4322,4724,5325,5926,6127,6728,7130,7332,7933,8334,8935,9736,10138,10339,10740,10942,11344,12745,13146,13748,13949,14950,15151,15752,16354,16755,17356,17957,18158,19160,19362,19763,19964,21165,22366,22768,22969",
			"name": "Concatenation of n-th prime and n-th nonprime.",
			"comment": [
				"Concatenate A000040(n) and A018252(n)."
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A253910/b253910.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e"
			],
			"example": [
				"a(5) = 119 because the 5th prime is 11 and the 5th nonprime is 9."
			],
			"program": [
				"(PARI) nprime(n)=c=0;k=1;while(k,if(!isprime(k),c++);if(c==n,return(k));k++)",
				"vector(50,n,eval(concat(Str(prime(n)),Str(nprime(n))))) \\\\ _Derek Orr_, Feb 06 2015",
				"(Haskell)",
				"import Data.Function (on)",
				"a253911 n = a253911_list !! (n-1)",
				"a253911_list = map read $",
				"   zipWith ((++) `on` show) a018252_list a000040_list :: [Integer]",
				"-- _Reinhard Zumkeller_, Feb 09 2015"
			],
			"xref": [
				"Cf. A000040, A018252, A038530, A045532, A075110, A106582, A138821, A138822, A253911."
			],
			"keyword": "nonn,base,easy",
			"offset": "1,1",
			"author": "_Omar E. Pol_, Feb 06 2015",
			"references": 2,
			"revision": 10,
			"time": "2015-02-09T15:47:40-05:00",
			"created": "2015-02-09T15:47:40-05:00"
		},
		{
			"number": 253911,
			"data": "12,43,65,87,911,1013,1217,1419,1523,1629,1831,2037,2141,2243,2447,2553,2659,2761,2867,3071,3273,3379,3483,3589,3697,38101,39103,40107,42109,44113,45127,46131,48137,49139,50149,51151,52157,54163,55167,56173,57179,58181,60191,62193,63197,64199,65211,66223,68227,69229",
			"name": "Concatenation of n-th nonprime and n-th prime.",
			"comment": [
				"Concatenate A018252(n) and A000040(n)."
			],
			"link": [
				"Reinhard Zumkeller, \u003ca href=\"/A253911/b253911.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e"
			],
			"example": [
				"a(5) = 911 because the 5th nonprime is 9 and the 5th prime is 11."
			],
			"program": [
				"(PARI) nprime(n)=c=0; k=1; while(k, if(!isprime(k), c++); if(c==n, return(k)); k++)",
				"vector(50, n, eval(concat(Str(nprime(n)), Str(prime(n))))) \\\\ Derek Orr, Feb 06 2015",
				"(Haskell)",
				"import Data.Function (on)",
				"a253911 n = a253911_list !! (n-1)",
				"a253911_list = map read $",
				"   zipWith ((++) `on` show) a018252_list a000040_list :: [Integer]",
				"-- _Reinhard Zumkeller_, Feb 09 2015"
			],
			"xref": [
				"Cf. A000040, A018252, A038530, A045532, A075110, A106582, A138821, A138822, A253910."
			],
			"keyword": "nonn,base,easy",
			"offset": "1,1",
			"author": "_Omar E. Pol_, Feb 06 2015",
			"references": 2,
			"revision": 10,
			"time": "2015-02-09T15:50:50-05:00",
			"created": "2015-02-09T15:50:50-05:00"
		}
	]
}