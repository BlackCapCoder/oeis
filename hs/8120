{
	"greeting": "Greetings from The On-Line Encyclopedia of Integer Sequences! http://oeis.org/",
	"query": "program:Haskell",
	"count": 8147,
	"start": 8120,
	"results": [
		{
			"number": 305461,
			"data": "1,2,2,3,2,4,2,3,4,4,2,6,2,4,4,5,2,8,2,6,4,4,2,6,6,4,4,6,2,8,2,5,4,4,4,12,2,4,4,6,2,8,2,6,8,4,2,10,8,12,4,6,2,8,4,6,4,4,2,12,2,4,8,9,4,8,2,6,4,8,2,12,2,4,12,6,4,8,2,10,10,4,2,12,4",
			"name": "The number of one-digit numbers, k, in base n such that k^2 and k^3 end in the same digit.",
			"comment": [
				"It appears that a(n) is equal to the number of factors of n, except when n cannot be divided by its multiplicative projection (A230542). - Ian Newman, Jun 01 2018",
				"Number of solutions to x^3 - x^2 == 0 (mod n). - _Andrew Howroyd_, Jul 22 2018"
			],
			"link": [
				"Matthew Scroggs, \u003ca href=\"/A305461/b305461.txt\"\u003eTable of n, a(n) for n = 1..1000\u003c/a\u003e",
				"Matthew Scroggs, \u003ca href=\"http://www.mscroggs.co.uk/puzzles/159\"\u003eSquare and cube endings\u003c/a\u003e."
			],
			"formula": [
				"Multiplicative with a(p^e) = p^floor(e/2) + 1 for prime p. - _Andrew Howroyd_, Jul 22 2018"
			],
			"example": [
				"In base 4,",
				"  0^2 =  0, 0^3 =   0,",
				"  1^2 =  1, 1^3 =   1,",
				"  2^2 = 10, 2^3 =  20,",
				"  3^2 = 21, 3^3 = 123.",
				"Three of these pairs have the same final digit, so a(4)=3."
			],
			"mathematica": [
				"Table[Count[Range@ n, _?(PowerMod[#, 2, n] == PowerMod[#, 3, n] \u0026)], {n, 85}] (* _Michael De Vlieger_, Jul 30 2018 *)"
			],
			"program": [
				"(Python) #",
				"for base in range(1,101):",
				"....n = 0",
				"....for j in range(base):",
				"........if (j**2)%base == (j**3)%base:",
				"............n += 1",
				"....print(base,n)",
				"(Haskell)",
				"a305461 n = length $ filter (\\i -\u003e (i^3 - i^2) `mod` n == 0) [0..n-1]",
				"-- _Peter Kagey_, Jun 10 2018",
				"(PARI) a(n) = sum(k=0, n-1, mk = Mod(k, n); mk^2 == mk^3); \\\\ _Michel Marcus_, Jul 03 2018",
				"(PARI) a(n)={my(f=factor(n)); prod(i=1, #f~, my(p=f[i,1], e=f[i,2]); p^(e\\2) + 1)} \\\\ _Andrew Howroyd_, Jul 22 2018"
			],
			"xref": [
				"A034444 is the number of one-digit numbers, k, in base n such that k and k^2 end in the same digit.",
				"Cf. A230542."
			],
			"keyword": "nonn,mult",
			"offset": "1,2",
			"author": "_Matthew Scroggs_, Jun 01 2018",
			"ext": [
				"a(1) inserted by _Andrew Howroyd_, Jul 22 2018"
			],
			"references": 1,
			"revision": 42,
			"time": "2018-08-23T17:04:16-04:00",
			"created": "2018-08-23T17:04:16-04:00"
		},
		{
			"number": 306216,
			"data": "1,1,0,0,-1,0,-1,0,-1,0,-1,0,-1,1,-1,1,-1,0,-1,0,-1,1,-1,1,-1,1,-1,1,-1,2,-2,2,-2,0,-1,0,-1,1,-1,1,-1,1,-1,1,-1,2,-2,2,-2,1,-1,1,-1,2,-2,2,-2,2,-2,2,-2,3,-4,4,-4,0,-1,0,-1,1,-1,1,-1,1,-1",
			"name": "Successive concatenation of the current sequence with the first differences of the sequence, a(1) = a(2) = 1.",
			"comment": [
				"n | generation             | first differences",
				"--+------------------------+-------------------",
				"1 | [1,1]                  | [0]",
				"2 | [1,1,0]                | [0,-1]",
				"3 | [1,1,0,0,-1]           | [0,-1,0,-1]",
				"4 | [1,1,0,0,-1,0,-1,0,-1] | [0,-1,0,-1,1,-1,1,-1]"
			],
			"link": [
				"Peter Kagey, \u003ca href=\"/A306216/b306216.txt\"\u003eTable of n, a(n) for n = 1..8193\u003c/a\u003e (first 14 generations)"
			],
			"mathematica": [
				"Nest[Join[#, Differences@ #] \u0026, {1, 1}, 7] (* _Michael De Vlieger_, Jan 29 2019 *)"
			],
			"program": [
				"(Ruby)",
				"generations = 10",
				"(1...generations).reduce([1,1]) do |s, _|",
				"  s += s.each_cons(2).map { |a, b| b - a }",
				"end",
				"(Haskell)",
				"a306216_list = 1 : 1 : concat (Data.List.unfoldr nextGeneration [1,1]) where",
				"  nextGeneration l = Just (diff l, l ++ diff l)",
				"  diff xs =  zipWith subtract xs (tail xs)"
			],
			"xref": [
				"Cf. A107946, A306211."
			],
			"keyword": "sign,look",
			"offset": "1,30",
			"author": "_Peter Kagey_, Jan 29 2019",
			"references": 1,
			"revision": 15,
			"time": "2019-02-01T01:33:09-05:00",
			"created": "2019-01-31T08:27:19-05:00"
		},
		{
			"number": 306998,
			"data": "2,9,10,16,22,25,26,27,28,35,36,40,51,52,56,57,58,66,70,78,82,86,87,88,92,93,94,95,96,121,122,123,124,125,126,135,136,145,146,147,148,162,171,172,177,178,187,188,189,190,209,210,215,216,217,218,219,220",
			"name": "List of low point records for pi(n)/n.",
			"comment": [
				"Let f(n) = pi(n)/n, where pi(n) is the prime-counting function (A000720). This sequence is the list of numbers n such that f(n) \u003c f(k) for 2 \u003c= k \u003c n.",
				"Because the primes generally become sparser forever, this list is infinite."
			],
			"link": [
				"Amiram Eldar, \u003ca href=\"/A306998/b306998.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e"
			],
			"example": [
				"f(10) = 0.4, which is smaller than f(2), f(3), ... , f(9), so 10 is in the list."
			],
			"mathematica": [
				"s={}; rm=1; Do[r = PrimePi[n]/n; If[r\u003crm, rm=r; AppendTo[s,n]], {n,2,1000}]; s (* _Amiram Eldar_, Mar 19 2019 *)"
			],
			"program": [
				"(Haskell)",
				"-- Very poor Haskell code, but let it stand until someone contributes the",
				"-- elegant three-liner that must exist. Its only merit is that it was actually",
				"-- used to produce the data given.",
				"isPrime :: Int -\u003e Bool",
				"isPrime = isPrime1 2",
				"isPrime1 :: Int -\u003e Int -\u003e Bool",
				"isPrime1 d n = n /= 1 \u0026\u0026 (d^2 \u003e n || mod n d /= 0 \u0026\u0026 isPrime1 (d+1) n)",
				"count :: (a -\u003e Bool) -\u003e [a] -\u003e Int",
				"count f [] = 0",
				"count f (x:xs) = (if f x then 1 else 0) + count f xs",
				"pdf :: Int -\u003e Double",
				"pdf n = fromIntegral (count isPrime [1..n]) / fromIntegral n",
				"isRecord :: Int -\u003e Bool",
				"isRecord n = (n == 2) || (pdf n) \u003c (minimum (map pdf [2..(n-1)]))",
				"records :: [Int]",
				"records = filter isRecord [2..100]"
			],
			"xref": [
				"Cf. A000720."
			],
			"keyword": "nonn,easy",
			"offset": "1,1",
			"author": "_Allan C. Wechsler_, Mar 18 2019",
			"ext": [
				"More terms from _Amiram Eldar_, Mar 19 2019"
			],
			"references": 1,
			"revision": 13,
			"time": "2019-03-20T07:01:33-04:00",
			"created": "2019-03-19T11:55:28-04:00"
		},
		{
			"number": 308339,
			"data": "21,30,49,51,75,82,96,106,120,130,133,136,141,148,152,157,161,173,177,180,186,187,189,202,207,209,213,217,221,226,236,240,242,244,248,261,264,277,285,286,294,305,306,311,317,320,322,327,333,349,355,364,368",
			"name": "Sphenic number indices of A215217.",
			"comment": [
				"A215217 is a subsequence of A007304 (by definition). The index sequence is more compact."
			],
			"link": [
				"Peter Dolland, \u003ca href=\"/A308339/b308339.txt\"\u003eTable of n, a(n) for n = 1..200\u003c/a\u003e"
			],
			"formula": [
				"A215217(n) = A007304(a(n))."
			],
			"example": [
				"For n = 3: a(3) = 49 and A215217(3) = 429 = A007304(49)."
			],
			"program": [
				"(Haskell)",
				"twinLowX [] = []",
				"twinLowX [_] = []",
				"twinLowX (n : (m : ns))",
				"    | m == n + 1 = 1 : (map succ (twinLowX (m : ns)))",
				"    | otherwise = (map succ (twinLowX (m : ns)))",
				"a308339 n = (twinLowX a007304_list) !! (n - 1)",
				"-- _Peter Dolland_, May 31 2019"
			],
			"xref": [
				"Cf. A007304, A215217."
			],
			"keyword": "nonn",
			"offset": "1,1",
			"author": "_Peter Dolland_, May 20 2019",
			"references": 1,
			"revision": 14,
			"time": "2019-06-01T10:14:58-04:00",
			"created": "2019-05-31T06:07:22-04:00"
		},
		{
			"number": 308495,
			"data": "2,3,5,8,13,16,22,25,32,41,45,55,62,66,73,83,94,98,109,117,120,132,138,150,166,173,177,185,188,196,224,231,243,247,267,271,284,295,303,315,327,331,353,356,364,368,394,419,426,430,439,452,456,475,487,500",
			"name": "a(n) is the position of the first occurrence of prime(n) in A027748.",
			"link": [
				"Alois P. Heinz, \u003ca href=\"/A308495/b308495.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e"
			],
			"formula": [
				"A027748(a(n)) = A000040(n).",
				"a(n) = 1 + A013939(A000040(n)). - _Charlie Neder_, Jun 04 2019",
				"a(n) = A082186(A000040(n)). - _Alois P. Heinz_, Jun 06 2019"
			],
			"example": [
				"For n = 5: a(5) = 13, A027748(13) = A000040(5) = 11."
			],
			"maple": [
				"b:= proc(n) option remember; `if`(n=1, 1,",
				"      b(n-1) +nops(ifactors(n)[2]))",
				"    end:",
				"a:= n-\u003e b(ithprime(n)):",
				"seq(a(n), n=1..60);  # _Alois P. Heinz_, Jun 06 2019"
			],
			"program": [
				"(Haskell)",
				"-- expected to be part of A027748",
				"a027748_list = concat (map a027748_row [1..])",
				"minIdx [] _ = []",
				"minIdx _ [] = []",
				"minIdx (a:as) (b:bs)",
				"    | a == b = 1 : (map succ (minIdx as bs))",
				"    | otherwise = map succ (minIdx as (b:bs))",
				"a308495_list = minIdx a027748_list a000040_list",
				"a308495 n = a308495_list !! (n-1)",
				"(PARI) a(n) = 1 + sum(k=1, prime(n), omega(k)); \\\\ _Michel Marcus_, Jun 05 2019"
			],
			"xref": [
				"Cf. A000040, A001221, A013939, A027748, A082186."
			],
			"keyword": "nonn",
			"offset": "1,1",
			"author": "_Peter Dolland_, Jun 01 2019",
			"references": 1,
			"revision": 27,
			"time": "2019-08-24T23:41:49-04:00",
			"created": "2019-06-06T20:19:17-04:00"
		},
		{
			"number": 309415,
			"data": "1,1,1,1,2,6,6,12,60,360,1260,10080,15120,25200,1247400,32432400,12612600,6810804000,7264857600,185253868800,1005663859200,1117404288000,4839757322400,93504111468768000,37401644587507200,160787493266400000,13023786954578400000",
			"name": "Number of different numbers that are formed by permuting digits of n!.",
			"comment": [
				"a(0) = 1 because 0! = 1 has one permutation (1).",
				"a(4) = 2 because 4! = 24 has two permutations (24, 42).",
				"a(5) = 6 because 5! = 120 has 6 permutations (012, 021, 102, 120, 201, 210)."
			],
			"link": [
				"Alois P. Heinz, \u003ca href=\"/A309415/b309415.txt\"\u003eTable of n, a(n) for n = 0..460\u003c/a\u003e"
			],
			"maple": [
				"a:= n-\u003e (l-\u003e combinat[multinomial](add(i, i=l), l[])",
				"      )([coeffs(add(x^i, i=convert(n!, base, 10)))]):",
				"seq(a(n), n=0..30);  # _Alois P. Heinz_, Jul 30 2019"
			],
			"mathematica": [
				"a[n_] := Block[{w = IntegerDigits[n!]}, Length[w]! / Times @@ ((Last /@ Tally[w])!)]; Array[a, 26, 0] (* _Giovanni Resta_, Jul 30 2019 *)"
			],
			"program": [
				"(Haskell)",
				"import Data.List (permutations, nub)",
				"factorial n = product [1..n]",
				"a309415 n = length $ nub $ permutations $ show $ factorial n",
				"map a309415 [0..]"
			],
			"xref": [
				"Cf. A000142, A047726."
			],
			"keyword": "nonn,base",
			"offset": "0,5",
			"author": "_Hauke LÃ¶ffler_, Jul 30 2019",
			"ext": [
				"More terms from _Giovanni Resta_, Jul 30 2019"
			],
			"references": 1,
			"revision": 15,
			"time": "2019-07-31T20:40:42-04:00",
			"created": "2019-07-30T04:34:57-04:00"
		},
		{
			"number": 316532,
			"data": "1,6,30,36,210,180,2310,216,900,1260,30030,1080,6300,13860,510510,1296,5400,7560,44100,69300,180180,9699690,6480,27000,37800,83160,485100,900900,3063060,223092870,7776,32400,45360,189000,264600,415800,1081080,5336100",
			"name": "Leading least prime signatures, ordered by the underlying partitions, as in A063008.",
			"comment": [
				"The sequence A063008 gives the least number with each prime signature, ordered by the underlying partition. This sequence is a subsequence which only includes those prime signatures M for which M/2 is not a prime signature, the so-called 'leading' least prime signatures.",
				"This sequence is therefore constructed by taking the partitions first in increasing order of their sum, then in decreasing order of the first term, then decreasing order of the second term, etc. We drop all partitions, except the empty partition, where the first term and the second term are different. Then we map (m1, m2, m3, ..., mk) to 2^m1 * 3^m2 * ... * pk^mk to give the terms of this sequence.",
				"The sequence A062515 had a description which suggested that it had been confused with this sequence. They are the same leading least prime signatures, but in a different order, given by a different construction using integer partitions."
			],
			"example": [
				"The first few partitions are [], [1,1], [1,1,1], [2,2], [1,1,1,1]. So the first few terms are 1, 2 * 3 = 6, 2 * 3 * 5 = 30, 2^2 * 3^2 = 36, 2 * 3 * 5 * 7 = 210."
			],
			"program": [
				"(Haskell)",
				"primes :: [Integer]",
				"primes = 2 : 3 : filter (\\a -\u003e all (not . divides a) (takeWhile (\\x -\u003e x \u003c= a `div` 2) primes)) [4..]",
				"divides :: Integer -\u003e Integer -\u003e Bool",
				"divides a b = a `mod` b == 0",
				"partitions :: [[Integer]]",
				"partitions = concat $ map (partitions_of_n) [0..]",
				"partitions_of_n :: Integer -\u003e [[Integer]]",
				"partitions_of_n n = partitions_at_most n n",
				"partitions_at_most :: Integer -\u003e Integer -\u003e [[Integer]]",
				"partitions_at_most _ 0 = [[]]",
				"partitions_at_most 0 _ = []",
				"partitions_at_most m n = concat $ map (\\k -\u003e map ([k] ++) (partitions_at_most k (n-k))) ( reverse [1..(min m n)])",
				"prime_signature :: [Integer] -\u003e Integer",
				"prime_signature p = product $ zipWith (^) primes p",
				"seq :: [Integer]",
				"seq = map prime_signature $ filter compare_first_second partitions",
				"    where",
				"  compare_first_second p",
				"        | length p == 0 = True",
				"        | length p == 1 = False",
				"        | otherwise = p!!0 == p!!1"
			],
			"xref": [
				"Subsequence of A063008. A re-ordering of A062515, also of A056153. Cf A025487."
			],
			"keyword": "nonn,easy",
			"offset": "0,2",
			"author": "_Jack W Grahl_, Jul 06 2018",
			"references": 1,
			"revision": 7,
			"time": "2018-07-15T13:42:13-04:00",
			"created": "2018-07-15T13:42:13-04:00"
		},
		{
			"number": 323186,
			"data": "0,-1,-1,0,2,3,3,2,0,-3,-5,-6,-6,-5,-3,0,4,7,9,10,10,9,7,4,0,-5,-9,-12,-14,-15,-15,-14,-12,-9,-5,0,6,11,15,18,20,21,21,20,18,15,11,6,0,-7,-13,-18,-22,-25,-27,-28,-28,-27,-25,-22,-18,-13,-7,0,8,15,21,26,30,33,35,36,36,35,33,30,26,21,15,8,0,-9,-17,-24,-30,-35,-39,-42,-44,-45,-45,-44,-42,-39,-35,-30,-24,-17,-9,0",
			"name": "a(0) = 0, a'(0) = 0, a''(0) = 1, a''(1) = -1, a(n) = a(n-1) + a'(n), a'(n) = a'(n-1) + a''(n), a''(n) = -a''(n-1) if a(n-2) = 0, or else a''(n-1).",
			"comment": [
				"This sequence might be called the \"Bad Driver's Sequence\" as it fully \"accelerates\" or \"decelerates\" when it changes side of its \"speed limit\"."
			],
			"link": [
				"Georg Fischer, \u003ca href=\"/A323186/b323186.txt\"\u003eTable of n, a(n) for n = 0..1000\u003c/a\u003e"
			],
			"formula": [
				"a'(n) = A053615(n)*(-1)^ceiling((sqrt(4n+1)-1)/2).",
				"a''(n) = (-1)^ceiling(sqrt(n)).",
				"a''(n) changes sign at A002522, a(n) = 0 at A005563.",
				"a(n) has local extrema (with a'(n) = 0) at the oblong numbers A002378 with the value of A000217(n)*(-1)^n, the magnitude of which is the corresponding triangular number, as such |a(n)| \u003c= n/2."
			],
			"example": [
				"a''(0) = 1, a'(0) = 0, a(0) = 0.",
				"a''(1) = -1, a'(1) = 0 - 1 = -1, a(1) = 0 - 1 = -1.",
				"a(2-2) = a(0) = 0, so a''(2) = -a''(1) = 1, a'(2) = -1 + 1 = 0, a(2) = -1 + 0 = -1."
			],
			"program": [
				"(Haskell)",
				"a(0) = 0",
				"a(1) = -1",
				"a(2) = -1",
				"a(n) = if a(n-2) == 0 then a(n-1) + a'(n-1) - a''(n-1) else a(n-1) + a'(n-1) + a''(n-1)",
				"where a'(n) = a(n) - a(n-1)",
				"      a''(n) = a'(n) - a'(n-1)",
				"(Perl)",
				"my @a = (0, -1, -1);",
				"for my $n (scalar(@a)..1000) {",
				"    if ($a[$n - 2] == 0) {",
				"        $a[$n] = $a[$n - 1] + \u0026as($n - 1) - \u0026ass($n - 1);",
				"    } else {",
				"        $a[$n] = $a[$n - 1] + \u0026as($n - 1) + \u0026ass($n - 1);",
				"    }",
				"    print \"$n $a[$n]\\n\";",
				"} # for n",
				"sub as  { my ($n) = @_; return $a[$n]  -  $a[$n - 1]; }",
				"sub ass { my ($n) = @_; return \u0026as($n) - \u0026as($n - 1); }",
				"# Georg Fischer, Feb 14 2019"
			],
			"xref": [
				"Cf. A000217, A000290, A002378, A002522, A005563."
			],
			"keyword": "sign,look",
			"offset": "0,5",
			"author": "_Thomas Anton_, Jan 06 2019",
			"ext": [
				"a(44) corrected [18, not -18] by _Tom Duff_, Feb 14 2019"
			],
			"references": 1,
			"revision": 28,
			"time": "2019-02-14T13:48:44-05:00",
			"created": "2019-02-14T12:40:18-05:00"
		},
		{
			"number": 325902,
			"data": "11,17,21,23,27,31,50,55,56,65,71,89,129,131,144,155,169,204,209,216,229,239,241,244,251,265,287,288,300,305,337,344,351,371,373,379,407,415,493,494,517,526,545,577,645,647,664,681,685,737,749,755,769,776,780,783,815",
			"name": "Numbers whose neighbor's prime factors with multiplicity can be partitioned into two multisets of equal sum.",
			"comment": [
				"The neighbors of n are the two numbers n-1 and n+1."
			],
			"link": [
				"Jonathan Frech, \u003ca href=\"/A325902/b325902.txt\"\u003eTable of n, a(n) for n = 1..10000\u003c/a\u003e"
			],
			"example": [
				"71 is in the sequence since 70 = 2*5*7 \u003c 71 \u003c 2*2*2*3*3 = 72 with 2 + 5 + 3 + 3 = 7 + 2 + 2 + 2."
			],
			"mathematica": [
				"ok[n_] := Block[{t, p, m, z}, {p, m} = Transpose@ Tally@ Sort[ Join@ Flatten[ ConstantArray @@@ FactorInteger[#] \u0026 /@ {n-1, n+1}]]; t = Total[p m]; If[ OddQ@ t, False, z = Quiet@ LinearProgramming[1 + 0 p, {p}, {{t/2, 0}}, Prepend[#, 0] \u0026 /@ Transpose@{m}, Integers]; ListQ@z \u0026\u0026 Total[z p]==t/2]]; Select[ Range[3, 815], ok] (* _Giovanni Resta_, Sep 10 2019 *)"
			],
			"program": [
				"(Haskell)",
				"import Data.List (subsequences, (\\\\))",
				"factors 1 = []",
				"factors n | p \u003c- head $ filter ((== 0) . mod n) [2..]",
				"          = p : factors (n `div` p)",
				"sumPartitionable ns | p \u003c- \\ms -\u003e sum ms == sum (ns \\\\ ms)",
				"                    = any p $ subsequences ns",
				"a325902 = filter (\\n -\u003e sumPartitionable $ factors (n-1) ++ factors (n+1)) [2..]"
			],
			"xref": [
				"Cf. A063968."
			],
			"keyword": "nonn",
			"offset": "1,1",
			"author": "_Jonathan Frech_, Sep 07 2019",
			"references": 1,
			"revision": 25,
			"time": "2019-09-10T23:34:01-04:00",
			"created": "2019-09-10T23:34:01-04:00"
		},
		{
			"number": 110910,
			"data": "1,2,2,2,3,8,13,15,49,22,17,17,16,26,29,41,34,25,21,26,21,21,36,31,29,95,25,29,34,38,105,150,61,582,43,58,92,108,263,277,50,212,59,53,57,99,55,170,196,812,105,54,53,85,59,81,0,418,63,63,314,117,118,170,236,104",
			"name": "Configurations in the evolution of a line of n cells in Conway's Game of Life, with 0=infinity. For periodic evolutions, a(n)=(preperiod length)+(period length). For non-periodic evolutions, a(n)=0.",
			"comment": [
				"If nothing catches up with an outbound glider, then a(n)=0 for n\u003e=1000 because when you watch the horizontal 1000-line evolve in a simulator, around the 490th generation, gliders fly away from the left and right corners _before_ the non-chaotic growing in the middle has finished, so you will see the same local picture in the 490th generation of longer lines."
			],
			"reference": [
				"Berlekamp/Conway/Guy, Winning Ways ..., 2nd ed, vol. 4, chapter 25"
			],
			"example": [
				"a(0)=1 because there is only the empty configuration. a(10)=2+15 because the 10-line needs two steps to become a pentadecathlon. a(56)=0 because the 56-line sends four gliders to outer space."
			],
			"program": [
				"(Haskell)",
				"{- program for verification of periodic cases. The non-periodic cases listed here evolve into a periodic kernel plus gliders whose paths ahead do not intersect each other or the kernel (gliders marching in single file are not counted as intersecting). Replace leading dots with spaces before running! -}",
				"import Data.Set",
				"main = print [if n `elem` known then 0 else a n | n\u003c-[0..105]]",
				"known = [56,71,72,75,78,82,85,86,87,88,91,92,93,94,96,98,100,102,103,105]",
				"a n = count empty (iterate evolve (fromList [(x,0) | x\u003c-[1..n]]))",
				"neighbors (x,y) = fromList",
				"................. [(x+u,y+v) | u\u003c-[ -1,0,1], v\u003c-[ -1,0,1], (u,v)/=(0,0)]",
				"evolve life =",
				". let fil f = Data.Set.filter",
				"............. (\\x-\u003e f (size (life `intersection` neighbors x)))",
				". in (life `difference` fil (\\k-\u003e k\u003c2 || k\u003e3) life) `union` fil (== 3)",
				".... (unions (Prelude.map neighbors (elems life)) `difference` life)",
				"count o (x:xs) | x `member` o = 0",
				".............. | otherwise = 1 + count (o `union` singleton x) xs"
			],
			"xref": [
				"Cf. A061342, A019473, A056605, A056614, A055397, A099733, A089520, A098720, A056613."
			],
			"keyword": "nonn,uned",
			"offset": "0,2",
			"author": "Paul Stoeber (pstoeber(AT)uni-potsdam.de), Oct 03 2005",
			"references": 0,
			"revision": 9,
			"time": "2018-12-26T03:42:22-05:00",
			"created": "2006-01-24T03:00:00-05:00"
		}
	]
}