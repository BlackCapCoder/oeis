{
	"greeting": "Greetings from The On-Line Encyclopedia of Integer Sequences! http://oeis.org/",
	"query": "program:Haskell",
	"count": 8147,
	"start": 8140,
	"results": [
		{
			"number": 206702,
			"data": "1,2,3,5,7,14,16,30,38,70,81,150,164,317,365,651,693,1376,1357,2728,2647,5458,5094,10645,10098,20657,18208,39071,33615,79672,61311,146648,115069,281652,211979,528417,362458,1014026,644778,1979453,1146748,3633995,2008902",
			"name": "The number of subsets X of Zn such that for all u, v in X, u+v is not in X.",
			"comment": [
				"Since the empty set and all the singletons except {0} have the required property, a(n) \u003e= n.  And clearly a(n) \u003c= 2^n, since there are only 2^n possible subsets. - _Michael B. Porter_, Feb 11 2012"
			],
			"example": [
				"a(5) = 7 because the following 7 subsets of {0,1,2,3,4} have the required property:",
				"  1:  { }",
				"  2:  { 1 }",
				"  3:  { 1, 4 }",
				"  4:  { 2 }",
				"  5:  { 2, 3 }",
				"  6:  { 3 }",
				"  7:  { 4 }"
			],
			"maple": [
				"b:= proc(i, n, s) local si; si:= s union {i};",
				"      `if`(i=0, 1, b(i-1, n, s) +`if`({seq(seq(irem(k+j, n)",
				"           , j=si), k=si)} intersect si={}, b(i-1, n, si), 0))",
				"    end:",
				"a:= n-\u003e b(n-1, n, {}):",
				"seq(a(n), n=1..25);  # _Alois P. Heinz_, Apr 24 2012"
			],
			"mathematica": [
				"b[i_, n_, s_] := Module[{si = s ~Union~ {i}}, If[i == 0, 1, b[i-1, n, s] + If[ Flatten[ Table[ Table[ Mod[k+j, n], {j, si}], {k, si}]] ~ Intersection~ si == {}, b[i-1, n, si], 0]]]; a[n_] := a[n] = b[n-1, n, {}]; Table[ Print[\"a(\", n, \") = \", a[n]]; a[n], {n, 1, 40}] (* _Jean-Fran√ßois Alcover_, Jun 07 2013, translated and adapted from _Alois P. Heinz_'s Maple program *)"
			],
			"program": [
				"(Haskell)",
				"import Control.Monad",
				"--this creates the powerset of a set",
				"ps n = filterM (\\x-\u003e[True,False]) n",
				"--given a set z, this creates the set X of (a+b) for all a, b, in Z",
				"addset z = do x\u003c-z",
				"              y\u003c-z",
				"              [x+y]",
				"--this check if two sets are disjoint",
				"disjoint a [] = True",
				"disjoint a (c:d) = (disjoint a d) \u0026\u0026 ((filter (\\x-\u003ex==c) a) ==[])",
				"--this checks if a set z is disjoint from its \"adsset\" in a certain Zn, n being the second argument.",
				"good z n = disjoint z (map (\\x-\u003erem x n) (addset z))",
				"--this generates all off Zn's subsets with the required property.",
				"sets n = filter (\\x -\u003egood x n) (ps [0..(n-1)])",
				"--this generates the first n terms of the sequence",
				"sequence n = map (\\x-\u003elength(sets x) ) [1..n]",
				"(PARI) a(n)=if(n\u003c4, return(n)); my(u,v=vector(n-2,i,[i]),s=n,t); while(#v, u=List(); for(i=1,#v, t=v[i]; for(m=t[#t]+1,n, if(setsearch(t,2*m%n)==0 \u0026\u0026 #setintersect(Set(vector(#t,k,t[k]+m)%n),t)==0 \u0026\u0026 #setintersect(vector(#t,k,m-t[#t-k+1]),t)==0, listput(u, concat(t, m))))); v=Vec(u); s+=#v); s \\\\ _Charles R Greathouse IV_, Jul 31 2016"
			],
			"keyword": "nonn,nice",
			"offset": "1,2",
			"author": "_Dan Fodor_, Feb 11 2012",
			"ext": [
				"More terms from _Joerg Arndt_, Feb 11 2012",
				"a(31)-a(43) from _Alois P. Heinz_, Apr 24 2012"
			],
			"references": 0,
			"revision": 35,
			"time": "2016-07-31T02:45:49-04:00",
			"created": "2012-02-13T20:08:48-05:00"
		},
		{
			"number": 287355,
			"data": "1,1,2,3,3,3,4,5,5,5,6,6,7,7,7,8,8,9,9,9,9,10,10,11,11,11,11,12,12,12,13,13,13,13,14,14,14,15,15,15,15,16,16,16,17,17,17,17,17,18",
			"name": "Order of largest subset of the positive rationals with neither the sum of numerators nor of denominators exceeding n.",
			"example": [
				"For n = 1, the largest subset is { 1/1 }, so a(1) = 1; for n = 2, the same; for n = 3, largest subsets are { 1/1, 2/1 } and { 1/2, 1/1 }, so a(3) = 2; for n = 4, the largest subset is { 1/2, 1/1, 2/1 }, so a(4) = 3; ...; for n = 16, the largest subset is { 1/4, 1/3, 1/2, 2/3, 1/1, 2/1, 3/1, 4/1 } (or swap 2/3 for 3/2), so a(16)=8, etc."
			],
			"program": [
				"(Haskell)",
				"f = go 0 2",
				"  where",
				"    go a r n",
				"      | n \u003e= c             = go (a+t) (r+1) (n-c)",
				"      | n \u003e= r*div n r + m = a + 2*div n r + 1",
				"      | n \u003e= r*div n r + m' + 1 = a + 2*div n r + 1",
				"      | otherwise          = a + 2*div n r",
				"      where",
				"        t  = totient r",
				"        c  = div (r*t) 2",
				"        m  = midnum r",
				"        m' = midnum (r-1)",
				"    midnum r = head [a|a\u003c-[div (r+1) 2..], gcd a r==1]"
			],
			"keyword": "nonn",
			"offset": "1,3",
			"author": "_Carl Edman_, May 23 2017",
			"references": 0,
			"revision": 14,
			"time": "2017-05-26T21:24:58-04:00",
			"created": "2017-05-26T21:24:58-04:00"
		},
		{
			"number": 288208,
			"data": "0,0,0,2,2,27,214,1695,15482,159019,1775664,21542628,282722448,3989526469,60239477384,969280731152",
			"name": "The number of permutations of a sequence of length n such that there are no fixed points, and no term is next to a term it was next to originally.",
			"comment": [
				"a(n) is bounded above both by A002464 and A000166.",
				"Math Stack Exchange link claims that the limit as n goes to infinity of A000166(n)/a(n) = e^2."
			],
			"link": [
				"Math Stack Exchange, \u003ca href=\"https://math.stackexchange.com/questions/2309850\"\u003eIf some series of n terms is deranged, what is the probability that no term stands next to a term it was next to originally?\u003c/a\u003e"
			],
			"example": [
				"For n = 4 the a(4) = 2 solutions are: [2,4,1,3] and [3,1,4,2].",
				"For n = 5 the a(5) = 2 solutions are: [3,1,5,2,4] and [2,4,1,5,3]."
			],
			"program": [
				"(Haskell)",
				"pairs l = zip l (drop 1 l)",
				"d n = filter (all (uncurry (/=)) . zip [1..]) $ Data.List.permutations [1..n]",
				"a n = length $ filter (all ((1\u003c) . abs . uncurry (-)) . pairs) $ d n"
			],
			"xref": [
				"Cf. A002464 is analogous without the fixed point restriction.",
				"Cf. A000166."
			],
			"keyword": "nonn,more",
			"offset": "1,4",
			"author": "_Peter Kagey_, Jun 06 2017",
			"ext": [
				"a(12)-a(16) from _Lars Blomberg_, Jul 05 2017"
			],
			"references": 0,
			"revision": 12,
			"time": "2017-07-05T22:55:04-04:00",
			"created": "2017-06-07T12:57:24-04:00"
		},
		{
			"number": 308267,
			"data": "1,2,4,7,8,14,16,28,31,32,56,62,64,83,112,124,127,128,166,224,248,254,256,332,397,448,496,508,511,512,664,794,891,896,992,1016,1022,1024,1163,1328,1588,1782,1792,1984,2032,2044,2047,2048,2326,2656,3176,3441,3564,3584,3968",
			"name": "Numbers which divide their Zeckendorffian format exactly.",
			"comment": [
				"Indices of A048678 which divide into their Zeckendorffian format.",
				"Curiously seems to include the powers of 2, some Mersennes and perfects.",
				"Fixed points of the Zeckendorf function are 2^k.",
				"All numbers 2^(2k+1)-1 are in this sequence, and that if n is in this sequence then so is 2n. - _Charlie Neder_, May 17 2019"
			],
			"example": [
				"The first few terms of A048678 are 1,2,5,4,9,10,21,8. 2 is a multiple of 2, 5 isn't a multiple of 3, 4 is a multiple of 4, 9 isn't a multiple of 5, 10 isn't a multiple of 6, 21 is a multiple of 7, etc."
			],
			"mathematica": [
				"Select[Range[4000], Divisible[FromDigits[Flatten[IntegerDigits[#, 2] /. {1 -\u003e {0, 1}}], 2], #] \u0026] (* _Amiram Eldar_, Jul 08 2019 after _Robert G. Wilson v_ at A048678 *)"
			],
			"program": [
				"(Haskell)",
				"import Data.Numbers.Primes",
				"bintodec :: [Int] -\u003e Int",
				"bintodec = sum . zipWith (*) (iterate (*2) 1) . reverse",
				"decomp :: (Integer, [Integer]) -\u003e (Integer, [Integer])",
				"decomp (x, ys) = if even x then (x `div` 2, 0:ys) else (x - 1, 1:ys)",
				"zeck :: Integer -\u003e String",
				"zeck n = bintodec (1 : snd (last $ takeWhile (\\(x, ys) -\u003e x \u003e 0) $ iterate decomp (n, [])))",
				"output :: [Integer]",
				"output = filter (\\x -\u003e 0 == zeck x `mod` x) [1..100]"
			],
			"xref": [
				"Cf. A048678, A083420 (subsequence)."
			],
			"keyword": "nonn,base",
			"offset": "1,2",
			"author": "_Dan Dart_, May 17 2019",
			"references": 0,
			"revision": 27,
			"time": "2019-07-09T13:17:45-04:00",
			"created": "2019-07-09T13:17:45-04:00"
		},
		{
			"number": 308576,
			"data": "1,3,7,11,23,35,71,75,87,159,319,321,481,483,559,583,659,1143,1303,1625,1661,1669,3295,3367,3443,4747,5331,5813,6957,12289,13915,19729,20873,22017,23643,24947,49895,51521,71251,122773,123257,123579,124163,127459,152407",
			"name": "a(n) = a(n-1) + a(a(n-1) mod n) + 1, a(0) = 1.",
			"formula": [
				"a(n) = a(n-1) + a(a(n-1) mod n) + 1, a(0) = 1."
			],
			"maple": [
				"a:= proc(n) option remember; `if`(n=0, 1,",
				"      a(n-1) + a(a(n-1) mod n) + 1)",
				"    end:",
				"seq(a(n), n=0..50); # _Alois P. Heinz_, Jul 08 2019"
			],
			"mathematica": [
				"a[0]=1; a[n_] := a[n] = a[n-1] + a[Mod[a[n-1], n]] + 1; Array[a, 50, 0] (* _Amiram Eldar_, Jul 08 2019 *)"
			],
			"program": [
				"(Java)",
				"int f(int n) {",
				"   int[] a = new int[n + 1];",
				"   a[0] = 1;",
				"   for (int i = 1; i \u003c n + 1; i++) a[i] = a[i - 1] + a[a[i - 1] % i] + 1;",
				"   return a[n];",
				"}",
				"(Haskell)",
				"a 0 = 1",
				"a n = (a (n - 1)) + (a (a (n - 1) `mod` n)) + 1",
				"(PARI) getV(n, v) = if (!v[n+1], v[n+1] = getV(n-1, v) + getV(getV(n-1, v) % n, v) + 1); v[n+1];",
				"lista(nn) = {my(v=vector(nn+1)); v[1] = 1; for (n=1, nn, v[n+1] = getV(n, v);); v;} \\\\ _Michel Marcus_, Jun 09 2019"
			],
			"keyword": "nonn",
			"offset": "0,2",
			"author": "_Artem Yashin_, Jun 08 2019",
			"ext": [
				"More terms from _Michel Marcus_, Jun 09 2019"
			],
			"references": 0,
			"revision": 17,
			"time": "2019-07-08T19:05:22-04:00",
			"created": "2019-07-08T19:05:22-04:00"
		},
		{
			"number": 309096,
			"data": "1,2,4,6,12,16,18,30,36,48,60,64,90,144,150,162,180,192,210,240,300,324,420,450,576,630,720,810,900,960,1050,1200,1260,1296,1458,1470,1620,1680,2100,2310,2880,2916,2940,3150,3600,3750,4050,4096,4410,4620,4800",
			"name": "Increasing positive integers with prime factorization exponents all appearing earlier in the sequence.",
			"formula": [
				"a(1) = 1; a(n) = least positive integer x \u003e a(n-1) where the exponents e in the prime factorization of x are in a(1..n-1)."
			],
			"example": [
				"a(2) = 2, since 2 = 2^1 and all {1} are in a(1..1) = [1].",
				"a(3) != 3, since 3 = 2^0 * 3^1 and not all {0,1} are in a(1..2) = [1,2].",
				"a(3) = 4, since 4 = 2^2 and all {2} are in a(1..2) = [1,2].",
				"a(4) != 5, since 5 = 2^0 * 3^0 * 5^1 and not all {0,1} are in a(1..3) = [1,2,4].",
				"a(4) = 6, since 6 = 2^1 * 3^1 and all {1} are in a(1..3) = [1,2,4]."
			],
			"program": [
				"(Haskell)",
				"wheelSeeds = [2, 3, 5, 7, 11, 13]",
				"wheelOffsets = filter (\\c -\u003e all (\\s -\u003e mod c s /= 0) wheelSeeds) [1..product wheelSeeds]",
				"restOfWheel = (concat (map (replicate (length wheelOffsets)) (map (* (product wheelSeeds)) [1..])))",
				"wheel = wheelSeeds ++ (tail wheelOffsets) ++ (zipWith (+) (cycle wheelOffsets) restOfWheel)",
				"isPrime n = and [n \u003e 1, all (\\c -\u003e mod n c /= 0) (takeWhile (\\c -\u003e c * c \u003c= n) wheel)]",
				"primes = filter isPrime wheel",
				"exponents bases acc n =",
				"    if (n == 1)",
				"        then (dropWhile (== 0) acc)",
				"        else if (mod n (head bases) == 0)",
				"            then (exponents bases (((head acc) + 1) : (tail acc)) (div n (head bases)))",
				"            else (exponents (tail bases) (0 : acc) n)",
				"a = filter (\\n -\u003e all (\\e -\u003e elem e (takeWhile (\u003c= e) a)) (exponents primes [0] n)) [1..]"
			],
			"keyword": "nonn",
			"offset": "1,2",
			"author": "_Chris Murray_, Jul 12 2019",
			"references": 0,
			"revision": 14,
			"time": "2019-07-13T01:26:33-04:00",
			"created": "2019-07-13T01:26:33-04:00"
		},
		{
			"number": 309979,
			"data": "4,1191,2340,4915,8101,8703,13937,13952,14029,14041,25111,25127,26062,26203,26324,26479,26490,27934,28077,28195,50506,50536,52216,52359,52892,55703,55957,56030,56059,56075,56178,56244,56566,56577,74747,75877,75952,75996,80752,80764,80765",
			"name": "Hash Parker numbers: Integers whose real 32nd root's first six nonzero digits (after the decimal point) rearranged in ascending order are equal to 234477.",
			"link": [
				"Matt Parker's YouTube Video, \u003ca href=\"https://www.youtube.com/watch?v=SOgn6J12NWE\"\u003eThe A4 Paper Puzzle\u003c/a\u003e"
			],
			"example": [
				"4^(1/32) = 1.0442737824274138...",
				"Rearranging 442737 in ascending order gives 234477.",
				"1191^(1/32) = 1.2477346... -\u003e 247734 -\u003e 234477;",
				"2340^(1/32) = 1.2743478... -\u003e 274347 -\u003e 234477."
			],
			"program": [
				"(Haskell)",
				"import Data.List",
				"hash :: Double -\u003e Inthash = read . sort . take 6 . filter (/='0') . drop 1 . dropWhile (/='.') . show . (** 0.03125)",
				"main :: IO ()main = print $ map (floor . fst) . filter ((==234477) . snd) $ map (\\x -\u003e (x, hash x)) [2..1000000]"
			],
			"keyword": "nonn,base",
			"offset": "1,1",
			"author": "_Dan Dart_, Aug 25 2019",
			"references": 0,
			"revision": 12,
			"time": "2019-08-28T14:49:12-04:00",
			"created": "2019-08-28T14:49:12-04:00"
		}
	]
}